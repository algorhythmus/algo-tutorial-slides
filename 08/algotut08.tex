%beamer

%\PassOptionsToClass{handout}{beamer}

\input{../preamble/tutpreamble}

\begin{document}
\starttut{8}

\thasse{
	\begin{frame}{Zu Blatt \#6}
		\textbf{Durchschnitt}: \quad etwa \thassedaniel{63}{81}~\% der Punkte
		\begin{itemize}
			\item Macht euch das Leben \textbf{leichter} und indiziert eure Arrays von $1...n$ (sofern es nützt, so wie in der A)
			\item Nutzt die Methode $\|swap|(a, b)$ zum Tauschen anstatt irgendwas mit $temp$ anzustellen.
			\implitem Vor allem in der \textbf{Klausur}, sonst verschwendet ihr Zeit!
		\end{itemize}
	\end{frame}

	\begin{frame}{Schwarzes Brett}
		Am \textbf{Mi, 20.06.} zum Algorithmen-Termin: \: \textbf{Probeklausur!}
		\begin{itemize}
			\item[\Pros\symbitemnegoffset] „Reale“ Klausurbedingungen
			\implitem Hingehen lohnt sich! Es gibt \sout{Kekse} (ÜB-)Punkte!
			\item Hilfsmittel: Einseitig beschriebenes Cheatsheet erlaubt (Tipp: Mit Druckbleistift kann man sehr klein schreiben ;) )
		\end{itemize}
	\end{frame}
}

\daniel{
	\begin{frame}{Zu Blatt \#7}
		\textbf{Durchschnitt}: \quad \thassedaniel{XXX}{XXX}~\% der Punkte
		\begin{itemize}
			\item 
		\end{itemize}
	\end{frame}
}
	
\begin{frame}[t]{Quiz}
	\ContentQuestion{Wie viele Elemente kann ein Heap der Höhe $h$ minimal/maximal haben?}{Minimal $2^{h-1}$, maximal $2^h - 1$.}
	\NoQuestion{Ist das Array $(23, 17, 14, 6, 13, 10, 1, 5, 7, 12)$ ein Min-Heap?}
	\FalseQuestion{In einem Max-Heap befindet sich das kleinste Element immer im untersten Level.}
	\YesQuestion{Ist ein aufsteigend sortiertes Array ein Min-Heap?}
\end{frame}	


\sectionheadframe{Sortierte Folgen}{Die eierlegende Wollmilchdatenstruktur}

\begin{frame}{Sortierte Folgen}
	\textbf{Heap- und stichfest?} 
	\begin{itemize}
		\item \textbf{Ziel}: eine \textbf{dynamische} und \textbf{stets sortierte} Datenstruktur
		\pause
		\item \textbf{Operationen}: \\ 
		\emph{Einfügen}, \\
		\emph{Entfernen}, \\
		\emph{Finden} des nächstkleineren/größeren Elements \\
		\impl \emph{so schnell wie möglich}
		\pause
		\item \textbf{Idee}: Binärer Heap – sieht sortiert aus, ist es aber \textbf{nicht}!
	\end{itemize}
\end{frame}

\begin{frame}{Sortierte Folgen}
	\textbf{Einfach sortierter Binärbaum} 
	\begin{itemize} 
		\item \textbf{Vorschlag}: Binärbaum mit strengerer Ordnung: \\
		$\forall v \in V : \ \text{LeftChild}(v) \leq v < \text{RightChild}(v)$
		\pause
		\item Intuitiv: Laufzeiten in $O(\log n)$ mittels \textbf{binärer Suche}
		\pause
		\item[\Cons] \textbf{Worst-Case}: Füge aufsteigende Folge ein \\
		\impl Lange Kette entsteht („Baum \textbf{unbalanciert}“), \\
		Laufzeiten in $O(n)$ \frownie \\
		\pause
		\impl I. A. eher ungeeignet
		\pause
		\implitem Wollen \textbf{balancierten} Baum (alle Blätter haben gleiche Tiefe) 
	\end{itemize}
\end{frame}

\begin{frame}{Sortierte Folgen}
	\textbf{(a, b)-Bäume} 
	\begin{itemize}
		\item \textbf{Besser}: Baum mit \textbf{flexiblem} Knotengrad \\
		\impl Anzahl \textbf{Kinder} zwischen $a...b$ \\
		{\small Ausnahme: Wurzel kann weniger haben}
		\item Dafür sinnvoll: $a \geq 2$ und $b \geq 2a-1$
		\pause
		\item Jeder \textbf{Knoten} hat ein \textbf{Navigations-Array}: \\
		Einträge mit $(k: \text{Key}, T_k: \text{Subtree})$: \\
		\quad $T_k$ führt nur zu Elementen $e \leq k$ \\
		\quad \textbf{Letzter} Eintrag: kein Key $k$, führt zu Elementen $e > \text{letztes } k$
		\pause
		\item \textbf{Blätter}: Eigentliche Elemente/Daten als \textbf{verkettete Liste}
		\pause
		\item Zur Vermeidung von Sonderfällen: \\ 
		„Dummy-Wert“ $\infty$ ganz am Ende
	\end{itemize}
\end{frame}

\begin{frame}{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Beispiel: (2, 4)-Baum} („00“ steht in VL für $\infty$) \\[0,125cm]
	\begin{figure}[htp]
		\centering
		\includegraphics[width=\textwidth]{baum24}
	\end{figure}
\end{frame}

%\begin{frame}{Sortierte Folgen}
%	\textbf{(a, b)-Bäume - Finden von (nächstkleineren/-größeren) Elementen} \\[0,125cm]
%	\begin{itemize}
%		\item Ziel: Finde in der sortierten Folge das nächstgrößte Element zum Wert $i$
%		\pause
%		\item Suche kleinstes Element $j$ im Navigationsarray des Knotens (der zu Beginn die Wurzel ist), für das gilt $i \leq j$, und fahre auf dem somit verlinkten Knoten fort (falls $j$ nicht vorhanden ist: Laufe rechteste Verlinkung entlang)
%		\pause
%		\item Wiederhole obiges, bis man auf der verlinkten Liste ankommt (was algorithmisch anhand einer zusätzlich stets brav verringerten Höhenvariable festgestellt wird)
%		\pause
%		\item Laufzeit?
%	\end{itemize}
%\end{frame}


\begin{frame}{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Finden von (nächstgrößeren {\small (-kleineren)}) Elementen}
	\begin{itemize}
		\item \textbf{Geg}.: Wert $e$ \\
		\textbf{Ges}.: (Nächstgrößeres) Element $z \geq e$
		\pause
		\implitem
			Starte bei \textbf{Wurzel} \\
			\pause
			\textbf{Suche} Element $j$ im Navigationsarray wobei\\
			\quad $j := \min\ \{\, j \mid e \leq j\,\}$ \\
			\pause 
			\textbf{Blatt-Ebene erreicht?} \impl \Return{$j$} \\
			Sonst \textbf{Wiederhole} auf Subtree von $j$ oder ganz rechtem Link falls $\nexists\ j$ 
		\item \textbf{Laufzeit} in \pause $O(b \cdot \text{Höhe}) = O(b \cdot \log_a n)$
		\pause
		\vspace{\baselineskip}
		\item Finden von \textit{nächstkleinerem} Element: \\ 
		\pause
		\quad Finde nächstgrößeres; \\
		\quad Falls $j \neq e$: Nehme Vorgänger von $j$ in verketteter Liste
	\end{itemize}
\end{frame}


\begin{frame}{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Finden von (nächstgrößeren {\small (-kleineren)}) Elementen} \\
	\medskip
	Beispiel: Suche nach 55: \\
	\centering 
	\includegraphics[width=\textwidth]{ab-find}
\end{frame}

\begin{frame}{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Einfügen von Elementen} 
	\begin{itemize}
		\item[1.] Finde Einfügestelle (wie beim Suchen)
		\visible<all:2->{\item[2a.] \textbf{Fall 1}: Platz im Navigationsarray frei? \\
			\impl Einfügen, \textcolor{blue}{im Nav-Array verlinken}, fertig! \smiley \\
			(falls neues Maximum: \textbf{Verlinkung anpassen}!)}
	\end{itemize}
	\centering  
	\only<all:1>{\includegraphics[width=\textwidth]{ab-insert-space-left-1}}
	\visible<all:2->{\includegraphics[width=\textwidth]{ab-insert-space-left-2}}
\end{frame}

\begin{frame}[t]{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Einfügen von Elementen} (Forts.)
	\begin{itemize}
		\item[2b.] \textbf{Fall 2}: Kein Platz im Nav-Array frei? \impl \emph{„split“} \\
		D.h. Element einfügen, Knoten \textbf{halbieren}: \\
		\textbf{Linker} Teil $L$ (enthält \textbf{Mittelelement} $M$), \textbf{Rechter} Teil $R$
	\end{itemize}
	\centering
	\vspace{1.4\baselineskip}
	\includegraphics[width=1.03\textwidth]{ab-insert-split-1}
\end{frame}

\begin{frame}[t]{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Einfügen von Elementen} (Forts.)
	\begin{itemize}
		\item [3.] Füge $M$ in Vorgänger ein, hänge $L$ als Subtree daran; $R$ hängt schon im Vorgänger \\
	\end{itemize}
	\centering
	\only<all:1>{\vspace{2.5\baselineskip}\includegraphics[width=1.03\textwidth]{ab-insert-split-2}}
	\only<all:2>{\includegraphics[width=1.03\textwidth]{ab-insert-split-3}}
	\visible<all:3->{\includegraphics[width=1.03\textwidth]{ab-insert-split-4}}
	\begin{itemize}
		\item<all:2->[4.] Vorgänger \textbf{voll}? \impl \textbf{Recurse} from step 2b. \\
		\visible<all:3->{Endet ggf. mit Anlegen einer \emph{neuen Wurzel}}
	\end{itemize}
\end{frame}

%\begin{frame}{Sortierte Folgen}
%	\textbf{(a, b)-Bäume - Entfernen von Elementen} \\[0,125cm]
%	\begin{itemize}
%		\item Finde das entsprechende Element und entferne es. Falls es sich um ein in seinem Teilbaum maximales Element handelt, muss die Verlinkung in Vorgängerknoten auf das neue Maximum aktualisiert werden.
%		\pause
%		\item Übrig gebliebener Knoten ist zu klein? Zwei Möglichkeiten:
%			\pause
%			\begin{itemize}
%				\item $"$Ausreichend leerer$"$ Nachbarknoten existiert? $\Rightarrow$ Füge beide Knoten zusammen ($"$fuse$"$)
%				\pause
%				\item Ansonsten gibt es einen $"$ziemlich vollen$"$ Nachbarknoten $\Rightarrow$ Zwacke von diesem ein paar (minimale) Elemente ab, um den Knoten wieder aufzufüllen ($"$balance$"$)
%				\pause
%				\item In allen Fällen das Anpassen der Verlinkungen in Vorgängerknoten nicht vergessen
%			\end{itemize}
%	\end{itemize}
%\end{frame}

\begin{frame}[t]{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Entfernen von Elementen} 
	\begin{itemize}
		\item<all:1->[1.] Einfach: Finden \visible<2-|handout:2->{und Entfernen. }\\
		\pause
		\visible<3-|handout:2->{Knotenmaximum wurde entfernt? \\ 
		\impl \textbf{Aktualisiere Verlinkung auf neues Maximum!}}
	\end{itemize}
	\forcenewline
	\only<all:1>{\includegraphics[width=1.03\textwidth]{ab-delete-1-before}}
	\only<2|handout:0>{\includegraphics[width=1.03\textwidth]{ab-delete-1-wrong}}
	\visible<3-|handout:2->{\includegraphics[width=1.03\textwidth]{ab-delete-1-right}}
\end{frame}

\begin{frame}[t]{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Entfernen von Elementen} 
	\begin{itemize}
		\item<all:1->[2.] Knoten jetzt \textbf{zu klein?} \\
		2a. \textbf{Fall 1}: ...und $\exists$ Nachbar, der leer genug? \\
		\impl \emph{„fuse“}: Knoten zusammenfügen \\
		\visible<all:2->{...und \textbf{Verlinkung anpassen!}}
	\end{itemize}	
	\only<all:1>{\includegraphics[width=1.03\textwidth]{ab-delete-2-fuse-1}}
	\visible<all:2->{\includegraphics[width=1.03\textwidth]{ab-delete-2-fuse-2}}
	\begin{itemize}
		\item<all:3->[] Vorgänger jetzt \textbf{zu klein}? \impl \textbf{Recurse} from step 2.
	\end{itemize}
\end{frame}

\begin{frame}[t]{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Entfernen von Elementen} 
	\begin{itemize}
		\item[2.] Knoten jetzt \textbf{zu klein?} \\
		2b. \textbf{Fall 2}: ...und $\exists$ Nachbar, der voll genug? \\
		\pause
		\impl \emph{„balance“}: Klaue Elemente vom fetten Nachbarn \\ 
		{\small (von links: maximale, von rechts: minimale Elemente)} \\
		\pause 
		...und \textbf{Verlinkung anpassen!}
	\end{itemize}
\end{frame}

\begin{frame}{Sortierte Folgen -- (a, b)-Bäume}
	\textbf{Laufzeiten}: \\[.5\baselineskip]
	$\casesr{\textit{locate} \\ \textit{insert} \\ \textit{remove}}$ in $O(b \cdot \text{Höhe}) = O(b \cdot \log_a n)$ \quad (für konst. $a$, $b$: $O(\log n)$).
\end{frame}

%\begin{frame}{Zur Übungsklausur}
%	\textbf{Colpa mia} \\[0,125cm]
%	\begin{itemize}
%		\item Aufgabe 1b) gab immer zwei Punkte, wenn irgendwas von Aufgabe 1 in irgendeiner Form bearbeitet war
%		\pause
%		\item Wer sich also trotzdem mit dem fehlerhaften $dpartition$-Algorithmus rumgequält hat, bekam zusätzliche Bonuspunkte
%	\end{itemize}
%\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% GRAPHEN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sectionheadframe{Graphen}{Der Plural, nicht der Kohlenstoff}

\begin{frame}{Graphen}
	\textbf{Wir erinnern uns ...} 
	\begin{itemize}
		\item Graph $G = (V, E)$ mit \textbf{Knoten}menge $V \neq \emptyset$ und \textbf{Kanten}menge $E$
		\pause
		\item \emph{Gerichteter} Graph: $E \subseteq V \times V$
		\item \emph{Ungerichteter} Graph: $E \subseteq \Big\lbrace \{u, v\} \bigm| u, v \in V \Big\rbrace$
		\pause
		\item Umwandlung \textit{ungerichtet} $\rightsquigarrow$ \textit{gerichtet} trivial \\ 
		\impl Im Folgenden stets \emph{gerichtete} Graphen
		\pause
		\item $n := |V|$
		\item $m := |E|$
		\pause
		\item Betrachten üblicherweise $V = \{1...n\}$ 
	\end{itemize}
\end{frame}

\begin{frame}{Repräsentationen von Graphen}
	\textbf{Kantenfolge} \\[0,125cm]
	\begin{itemize}
		\item {\small (Zusammenhängender)} Graph eindeutig definiert durch \textbf{Menge aller Kanten} (Reihenfolge egal)
		\pause
		\item Knoten $v$ existiert in $G$ \\ 
		\gdw $\exists\ (v, x) \text{ oder } (x, v) \in \textit{Kantenliste}$ \quad ($x$ beliebig)
		\pause
		\item[\Pros] \textbf{Kompakt} \impl Gut handhabbar (im Speicher oder bei I/O)
		\pause
		\item[\Cons] Einzige effiziente Operation: \textbf{Durchlaufen} aller Kanten
	\end{itemize}
	\begin{figure}[htp]
		\centering
		\includegraphics[width=12cm]{kantenliste}
	\end{figure}
\end{frame}

\begin{frame}{Repräsentationen von Graphen}
	\textbf{Adjazenzmatrix} \\
	Verwende Matrix $A \in \{0, 1\}^{n \times n}$ \ mit \ $a_{ij} = 1 \gdw (i, j) \in E$
	
	\bigskip
	\begin{columns}
		\column{0.4\linewidth}
		\begin{tikzpicture}[->,>=stealth,baseline=-5mm]
		\matrix[matrix of math nodes,nodes={draw,circle,minimum size=5mm,inner sep=2pt},row sep=10mm,column sep=10mm,ampersand replacement=\&]
		{
			|(0)| 0 \& |(1)| 1 \& |(2)| 2 \\
			\& |(3)| 3 \& \\
		};
		\draw  (0) -- (1);
		\draw  (0) -- (3);
		\draw (1) -- (3);
		\draw  (2)  to [bend left] (3);
		\draw  (2) -- (1);
		\draw  (3) to [bend left] (2);
		\draw  (0) to [bend left]  (2);
		\path (2) edge [loop right] ();
		\end{tikzpicture}
		\column{0.4\linewidth}
		$$ A = \begin{pmatrix} 0 & 1 & 1 & 1 \\ 0 & 0 & 0 & 1 \\ 0 & 1 & 1 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix} $$
	\end{columns}
%	\begin{figure}[htp]
%		\centering
%		\includegraphics[width=\textwidth]{adjazenzmatrix}
%	\end{figure}
\end{frame}

\begin{frame}{Repräsentationen von Graphen}
	\textbf{Adjazenzmatrix} 
	\begin{itemize}
		\item[\Pros] recht \textbf{platzeffizient}, falls Graph dicht
		\pause
		\item[\Pros] \textbf{Einfügen}, \textbf{Löschen}  und \textbf{Testen} von Kanten in $O(1)$ und simpel
		\pause
		\item[\Pros] $\{0, 1\} \rightsquigarrow \R$ erweitern für \textbf{Kantengewichte}
		\pause
		\item[\Pros] LA, yay! :D
	\end{itemize}
	\begin{itemize}
		\pause
		\item[\Cons] platz\textbf{in}effizient bei dünnbesetzten Graphen \\ 
		{\small (also durchschn. Knotengrad $\ll n$)}
		\pause
		\item[\Cons] \textbf{langsame} Navigation
		\pause
		\item[\Cons] LA \textit{*kotz*} 
	\end{itemize}
\end{frame}

\begin{frame}{Repräsentationen von Graphen}
	\textbf{Adjazenzfeld (aka Adjazenzarray)} 
	\begin{itemize}
		\item 
		\begin{tabbing}
			Definiere \= $V : \KwArray[1 \dots n+1] \KwOf \{1 \dots m+1\}$ und \\
			\> $E : \KwArray[1 \dots m] \KwOf \{1 \dots n\}$
		\end{tabbing}
		\pause
		\item Von $v$ erreichbare Knoten: $\big\lbrace\, E[i] \mid V[v] \leq i < V[v+1] \, \big\rbrace$
		\pause
		\item \emph{„Dummy-Eintrag“}: \\
		$V[n+1] := m+1$, damit oben $v = n$ nicht knallt
	\end{itemize}
	\visible<2->{\begin{figure}[htp]
			\centering
			\includegraphics[width=\textwidth]{adjazenzfeld}
		\end{figure}}
\end{frame}
	
\begin{frame}{Repräsentationen von Graphen}
	\textbf{Adjazenzfeld (aka Adjazenzarray)} 
	\begin{itemize}
		\item[\Pros] \textbf{Navigation} gut möglich
		\pause
		\item[\Pros] \textbf{Zusatzinfos} (z.~B. Kantengewichte) durch weitere Arrays leicht aufrüstbar
		\pause
		\item[\Pros] \textbf{Cachefreundlich}
		\pause
		\item[\Pros] Nachrüstbar: Kanten \textbf{löschen}, \textbf{rückwärts} laufen 
	\end{itemize}
	\begin{itemize}
		\pause
		\item[\Cons] Hinzufügen von Kanten scheiße \quad (\#ArraysHalt...)
	\end{itemize}
\end{frame}

\begin{frame}{Repräsentationen von Graphen}
	\textbf{Adjazenzliste} 
	\begin{itemize}
		\item Verwende $\KwArray A[1...n]$ von verketteten Listen
		\pause
		\item $A[v]$: Liste aller von $v \in V$ aus \textbf{erreichbaren Knoten} \\
		\forcenewline
		\pause
		\item[\Pros] Alle Features vom Adjazenzfeld
		\pause
		\item[\Pros] ...und noch mehr: \textbf{Einfügen}, \textbf{Löschen} von Kanten 
		\pause
		\item[\Cons] Benötigt mehr \textbf{Platz} (für Zeiger)
		\pause
		\item[\Cons] \textbf{Cachefeindlicher}
	\end{itemize}
	\begin{figure}[htp]
		\centering
		\includegraphics[width=.6\textwidth]{adjazenzliste}
	\end{figure}
\end{frame}


\begin{frame}{Repräsentationen von Graphen}
\taskheading{Lesen in der Matrix}
\begin{columns}
\column{0.4\linewidth}
$$ A = 
\begin{pmatrix} 
1 & 1 & 0 & 1 & 0 & 0 \\ 
0 & 0 & 0 & 1 & 0 & 0 \\ 
0 & 1 & 1 & 1 & 0 & 0 \\ 
0 & 0 & 1 & 0 & 0 & 0 \\
1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
\end{pmatrix} $$

\column{0.4\linewidth}
\only<7->{
	\begin{tikzpicture}[->,>=stealth,baseline=-5mm]
	\matrix[matrix of math nodes,nodes={draw,circle,minimum size=6mm,inner sep=2pt},row sep=13mm,column sep=10mm,ampersand replacement=\&]
	{
		|(0)| 0 \& |(1)| 1 \& |(2)| 2 \\
		|(4)| 4 \& |(3)| 3 \& |(5)| 5 \\
	};
	\draw  (0) -- (1);
	\draw  (0) -- (3);
	\draw  (4) -- (0);
	\draw  (1) -- (3);
	\draw  (2)  to [bend left] (3);
	\draw  (2) -- (1);
	\draw  (3) to [bend left] (2);
	\path  (2) edge [loop right] ();
	\path  (0) edge [loop left] ();
	\end{tikzpicture}
}
\end{columns}

\bigskip
Was kann man an der Adjazenzmatrix ablesen?
\begin{itemize}
\item Gerichtet oder ungerichtet? \pause \impl gerichtet (weil $A$ nicht symm.) \pause
\item Schlingen?  \pause \impl Auf der Diagonalen von $A$: \quad Knoten 0, 2 \pause
\item Zusammenhängend? \pause \impl Nein (5 ist isoliert). 
\item Zeichnet den Graphen und stellt ihn als Adjazenzfeld und Kantenfolge dar (alphabetisch geordnet).
\end{itemize}
\end{frame}

\begin{frame}{Repräsentationen von Graphen}
	\taskheading{Malen nach Zahlen}
	Stellt diesen Graphen als Adjazenzfeld, Adjazenzmatrix und Kantenfolge dar (alphabetisch geordnet). \vspace{-.3\baselineskip}
	\begin{figure}[htp]
		\centering
		\includegraphics[height=6cm]{beispielgraph-edited}
	\end{figure}
\end{frame}
	
\begin{frame}{Graphenbeweise}
	\taskheading{I Wanna Ride My Acycle!} 
	Es sei $G = (V, E)$ ein gerichteter azyklischer Graph (DAG) mit endlich vielen und mindestens einem Knoten. Zeige, dass $G$ mindestens einen Knoten mit Eingangsgrad 0 besitzt. \\
	\pause
	\bigskip
	\solutionheading
	Angenommen, jeder Knoten hat Eingangsgrad $\geq 1$. ($=$ Gegenteil.) \\ 
	Nehme irgendeinen Knoten $v$. Auf diesen zeigt also garantiert ne \textbf{Kante}. Laufe sie \textbf{rückwärts} $\rightsquigarrow$ neuer Knoten. \textbf{Wiederhole} beliebig oft (das geht dank Annahme!). \\
	Also geht das öfter, als $G$ Knoten hat \impl Irgendwann ein Knoten 2x besucht \impl Wir laufen im Kreis \impl \crash $G$ kreisfrei. 
\end{frame}

\xkcdframevert{1897}{Danke für eure Aufmerksamkeit! \smiley}{2}

\only<beamer:0>{\slideThanks}

\end{document}