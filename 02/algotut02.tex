%beamer

%TODO: Selsort-Invbsp. doch dranbringen!

\input{../preamble/tutpreamble}

\begin{document}

\starttut{2}

% presentation

\begin{frame}[t]{Quiz}
	\thasse{\Socrative}
	\FalseQuestion{Für alle Funktionen $f, g$ gilt $f(n) < g(n)$ oder $f(n) = g(n)$ \\ oder $f(n) > g(n)$.}
	\FalseQuestion{$e^n \in \Oh{2^n}$.}
	\TrueQuestion{$e^n \in \Oh{n!}$.}
	\FalseQuestionE{Für Pseudocode gilt die DIN~1946-6.}{Diese Norm regelt die Anzahl und Dauer von Lüftvorgängen in \\ Wohnungen.}
\end{frame}

\iffalse

\begin{frame}{Zum letzten Übungsblatt (Nr. 1)}
	\textbf{Aufgabe 4} \\[0,125cm]
	\begin{itemize}
		\item Man hat ein Array $A$ von (beliebigen) Elementen und möchte zu jedem Element $"$Zusatzinformationen$"$ anlegen (hier: Ein $bool(ean)$ pro Zahl, ob diese zusammengesetzt ist oder nicht)
		\item Wenn man beim Abrufen der Zusatzinformation eines Elementes $e$ auch den Index $i$ von $e$ in $A$ hat (wie es hier der Fall ist, da über den Inhalt von $A$ iteriert wird), bietet es sich an, diese Zusatzinformationen in einem Array $B$ der Größe $|A|$ zu speichern, also $Zusatzinformation(A[i]) = B[i]$
	\end{itemize}
\end{frame}

\begin{frame}{Zum letzten Übungsblatt (Nr. 1)}
	\textbf{Aufgabe 4} \\[0,125cm]
	\begin{itemize}
		\item In Bezug auf die Aufgabe im Übungsblatt also: \\
		\footnotesize
		\begin{exampleblock}{ }
			\begin{algorithm}[H]
				\DontPrintSemicolon
				$function\ decideIfZusammengesetzt(M : Sorted\ Array\ of \Z) : Array\ of\ bool(ean)$\;
				\Begin{
					$B[|M|] : Array\ of\ bool(ean)$\;
					\For{$i\ \KwFrom\ 0\ \KwTo\ |M|-1$} {
						//Entscheide, ob $M[i]$ zusammengesetzt ist\;
						\uIf{$M[i]\ ist\ zusammengesetzt$} {
							$B[i] := true$\;
						}
						\Else {
							$B[i] := false$\;	
						}
					}
					\KwRet{$B$}\;
				}
			\end{algorithm}
		\end{exampleblock}
	\end{itemize}
\end{frame}


\begin{frame}{Zum letzten Übungsblatt (Nr. 1)}
	\textbf{O-Kalkül} \\[0,25cm]
	\begin{itemize}
		\item Aufgabe 1 war sehr mathematisch, dafür können die bewiesenen Zusammenhänge künftig als gegeben betrachtet werden (falls die Aufgabenstellung keinen erneuten Beweis verlangt)
		\item Zur Angabe von Laufzeiten
		\begin{itemize}
			\item Falls eine obere Schranke gefordert wird $\Rightarrow O(f(n))$ (potenziell $"$zu große$"$ Schranke) ausreichend
			\item Falls eine scharfe asymptotische Grenze gefordert wird $\Rightarrow \Theta(f(n))$ benötigt
			\item Falls die Laufzeit eines (spezifischen) Algorithmus angegeben bzw. bestimmt werden soll $\Rightarrow \Theta(f(n))$ gefordert
		\end{itemize}
	\end{itemize}
\end{frame}



\begin{frame}{Zum letzten Blatt (\#1)} %TODO adapt to current sheet
	\begin{itemize}
		\item \textbf{Aussage} + \textbf{Begründung} irgendwie deutlich machen
		\item \textbf{Form}: Definieren, was ihr benutzt (Wo kommen $f$ und $g$ her??)
		\pause
		\item Induktion: Hübsche Rechnung. \textbf{Und was heißt das jetzt?} (Zusammenhang Rechnung $\Leftrightarrow$ Code-Geschehen nicht vergessen!)
		\item Induktion mittels $a \rightsquigarrow a + 1$ gefährlich: Wo wird a erhöht? \\ ($c$ genauso: Wird in der \textit{Mitte} erhöht!) \\
		$\impl$ Besser: Schleifendurchläufe \textbf{nummerieren} ($i$) und Variablen auch ($a_i, b_i,...$)!
	\end{itemize} 
\end{frame}

\begin{frame}{Zum letzten Blatt (\#1)}
	\begin{exampleblock}{Aufgabe 2 c)}
		\begin{algorithm}[H]
			\Function{f$(n, m : \N): (\N_0, \N_0)$}{
				$a = 0 : \N_0$ \;
				$b = m : \N_0$ \;
				$c = 1 : \N_0$ \;
				\While{$m - c \cdot n \geq 0$}{
					\only<2>{$\KwInvariant m = a \cdot n + b$ \;}
					$a := c$ \;
					$c := c+1$ \;
					$b := m - a \cdot n$ \;
				}
				\Return{$(a,b)$}
			}
		\end{algorithm}
	\end{exampleblock}
\end{frame}

\begin{frame}{Lösung Aufgabe 2 c)}
	Bezeichne $i$ die Nummer des aktuellen Schleifendurchlaufs und $a_i, b_i, c_i$ den Wert von a, b, c zu Beginn von Schleifendurchlauf $i$. \\
	\pause
	\hanging \textbf{IA}. ($i=1$): \quad $a_1 \cdot n + b_1 = 0 \cdot n + m = m. \quad \checkmark$ \\
	\pause
	\hanging \textbf{IV}.: Die Invariante galt zu Beginn von Schleifendurchlauf $i$. \\
	\pause
	\hanging {\textbf{IS}. ($i \rightsquigarrow i + 1$): Es gilt zu Beginn von Schleifendurchlauf $i+1$: \newline
		$a_{i+1} = c_i$, \newline
		$b_{i+1} = m - a_{i+1} \cdot n$. \newline
		\hspace*{-0.4cm}$\Impl a_{i+1} \cdot n + b_{i+1} = c_i \cdot n + \left(m - c_i \cdot n\right) = m. \qed$
	}
\end{frame}

\fi

\sectionheadframe{Laufzeiten}{...denn Zeit ist Geld}

\begin{frame}{Laufzeitabschätzung}
	\vspace{-1.5\baselineskip}
	\begin{columns}[T] 
		\begin{column}[T]{.45\textwidth} 
			\begin{exampleblock}{Laufzeit?}
				\begin{algorithm}[H]
					\Function{boing$(n: \N): \N$}{
						$k := 0$\;
						$\ell := 0$\;
						\For{$i := 1 \KwTo n$} {
							$\ell\pp$\;
							\If{$i > n - 4$} {
								\For{$j := 1 \KwTo n$} {
									$k\pp$\;
								}
							}
						}
						\KwRet{$k+\ell$}\;
					}
				\end{algorithm}
			\end{exampleblock}
		\end{column}
		\pause
		\begin{column}[T]{.52\textwidth} 
			\begin{itemize}
				\item Erster Gedanke: \\ 
				\textbf{Äußere} Schleife: $n$ Durchläufe, \\ 
				\textbf{Innere} Schleife: $n$ Durchläufe \\ 
				\only<2|handout:0>{\impl Laufzeit in $\Theta(n \cdot n) = \Theta(n^2)$}
				\only<3>{\impl Laufzeit in $\xcancel{\Theta(n \cdot n) = \Theta(n^2)}$}
				\pause
				\item \textbf{Aber}: Innere Schleife wird nur \textbf{max. 4x} erreicht \\ (nämlich für \\  $i \in \{n-3, n-2, n-1, n\}$) \\
				\medskip
				$\impl \text{Laufzeit in } \Theta(n + 4n) = \Theta(n)$
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}


\begin{frame}{Laufzeitabschätzung}
	\begin{exampleblock}{Laufzeit?}
		\begin{algorithm}[H]
			\Function{doing$(n: \N): \N$}{
				$k := 0$\;
				$\ell := 0$\;
				\For{$i := 1 \KwTo n$} {
					$\ell\pp$\;
					\For{$j := i \KwTo n$} {
						$k\pp$\;
					}
				}
				\KwRet{$k+\ell$}\;
			}
		\end{algorithm}
	\end{exampleblock}
\end{frame}

\begin{frame}{Laufzeitabschätzung}
	\begin{itemize}
		\item Erster Gedanke: Äußere Schleife macht $n$-mal „irgendwas“ $\impl n \cdot (???)$ \\
		(Klammer? Wie schreiben wir das auf? Nicht $n$-mal dasselbe, sondern \textbf{von $i$ abhängig}!) 
		\pause
		\item Rettung: Anzahl innere Schleifendurchläufe \textbf{einzeln} für jedes $i = 1,\dots,n$ \textbf{aufsummieren}!
		\pause
		\item Für ein festes $i$ wird innere Schleife $(n-i+1)$-mal durchlaufen
		\pause
		\impl Gesamtanzahl der inneren Schleifendurchläufe:
		\begin{align*}
			&\sum\limits_{i=1}^n (n-i+1) =
			\sum\limits_{i=1}^n n - \sum\limits_{i=1}^n i + \sum\limits_{i=1}^n 1 = 
			n^2 - \sum\limits_{i=1}^n i + n      \\ \pause
			\vphantom{.} = \vphantom{.}&n^2 - \frac{n \cdot (n+1)}{2} + n =
			n^2 - \frac{n^2}{2} + n - \frac{n}{2} =
			\frac{n^2 + n}{2} \in \Theta(n^2).
		\end{align*}
	\end{itemize}
\end{frame}


\begin{frame}{Laufzeitabschätzung}
	\begin{columns}[T] 
		\begin{column}[T]{.45\textwidth}
			\vspace{-\baselineskip} 
			\begin{exampleblock}{Laufzeit?}
				\begin{algorithm}[H]
					\Function{going$(n: \N): \N$}{
						$k := 0$\;
						$\ell := 0$\;
						\For{$i := 1 \KwTo n$} {
							$\ell\pp$\;
							\If{$i > n - 4$} {
								\For{$j := i \KwTo n$} {
									$k\pp$\;
								}
							}
						}
						\KwRet{$k+\ell$}\;
					}
				\end{algorithm}
			\end{exampleblock}
		\end{column}
		\pause
		\begin{column}[T]{.53\textwidth} 
			Die innere Schleife wird wieder \textbf{nur max. vier Mal} erreicht (s. \emph{boing})  \\ 
			(nämlich für $i \in \{n-3, n-2, n-1, n\}$). \\ 
			\smallskip \pause
			\impl Die innere Schleife wird erst vier-, dann drei-, dann zwei- und dann einmal durchlaufen \\ 
			\medskip
			\impl Laufzeit in $\Theta(n + 4+3+2+1) = \Theta(n)$
		\end{column}
	\end{columns}
	
\end{frame}

\begin{frame}{Laufzeitabschätzung}
	\textbf{Hinweise für Aufgaben} \\[0,25cm]
	\begin{itemize}
		\pause
		\item „Obere Schranke“ gefordert \\ 
		$\impl O(f(n))$ (potenziell „zu große“ Schranke) ausreichend
		\pause
		\item „\textbf{Scharfe} asymptotische Schranke“ gefordert \\ $\impl \Theta(f(n))$ benötigt
		\pause
		\item Laufzeit eines Algorithmus soll angegeben bzw. bestimmt werden \\ \impl Offiziell $\Theta(f(n))$ erwünscht \\ (in VL oder Musterlösungen aber oft auch $O(f(n))$)
	\end{itemize}
\end{frame}

\sectionheadframe{Das Master-Theorem}{\textit{Das} Thema des Bachelors}   % Alternativ: Segelschiff-Anspielung „Zweimaster“ oder so?

\begin{frame}{Rekurrenzen}
	\textbf{Problemstellung:} Finde Laufzeit von \emph{rekursiven} Algorithmen.
	
	\begin{exampleblock}{Beispiel}
		\begin{algorithm}[H]
			\KwMethod Foo$(L: \|List| \: \KwSty{with} \size{L} = n)$\KwEmptyBlock{
				\If{$n \leq \textcolor{blue}{b}$}{\Return{$L$}}
				teile $L$ in $\textcolor{blue}{b}$ Teile $L_1, \dots$ auf \;
				\For{$i := 1 \KwTo \textcolor{darkgreen}{d}$} {
					$R_i := \|Foo|(L_i)$\;
				}
				führe alle $R_i$ in Laufzeit $c\·n$ zusammen
			}
		\end{algorithm}
	\end{exampleblock}
\end{frame}

\begin{frame}{Rekurrenzen}
	\textbf{Problemstellung:} Finde Laufzeit von \emph{rekursiven} Algorithmen.
	
	\textbf{Vorgehen:}
	\begin{enumerate}
		\item Rekurrenzgleichung aufstellen:\\
		Abschätzen der Laufzeit $T(n)$ \enquote{wie vorhin am Code}, dabei für Foo $T(n)$ einsetzen.
		\[
		T(n) = 
		\begin{cases}
		a,  & \text{für } n = 1 \\
		\textcolor{darkgreen}{d} \cdot T\large(\frac{n}{\textcolor{blue}{b}}\large) + c\·n, & \text{für } n > 1
		\end{cases}
		\]
		
		\pause
		\item Auflösen:\\ 
		Mit Master-Theorem (wenn möglich), ansonsten von Hand.
	\end{enumerate}

\end{frame}

\begin{frame}{Das Master-Theorem (einfache Form)} % TODO ceil the fraction?
	Seien $a, \textcolor{blue}{b}, c, \textcolor{darkgreen}{d}$ positive Konstanten und für $n \in \N$ sei 
	\[
	T(n) = 
	\begin{cases}
	a,  & \text{für } n = 1 \\
	\textcolor{darkgreen}{d} \cdot T\large(\frac{n}{\textcolor{blue}{b}}\large) + c\·n, & \text{für } n > 1
	\end{cases}
	\]
	gegeben. \\ \smallskip
	
	Dann gilt:
	\[
	T(n) \in 
	\begin{cases}
	\Th{n},                                                        & \textcolor{darkgreen}{d} < \textcolor{blue}{b} \\
	\Th{n \log n},                                                 & \textcolor{darkgreen}{d} = \textcolor{blue}{b} \\
	\Th{n^{\log _{\textcolor{blue}{b}} \textcolor{darkgreen}{d}}}, & \textcolor{darkgreen}{d} > \textcolor{blue}{b}
	\end{cases}.
	\]
\end{frame}

\begin{frame}[t]{Master-Theorem: Beispiele} 
	Wir betrachten verschiedene Sortierverfahren:\\
	\bigskip
	
	\begin{exampleblock}{Mergesort}
		\begin{algorithm}[H]
			\KwMethod Mergesort$(L: \|List| \: \KwSty{with} \size{L} = n)$\KwEmptyBlock{
				teile $L$ in der Mitte auf in $L_1$ und $L_2$ \;
				sortiere $L_1$ und $L_2$ rekursiv mit Mergesort \;
				füge $L_1$ und $L_2$ in $\Th{n}$ zusammen
			}
		\end{algorithm}
	\end{exampleblock}	
	
	\[\text{Laufzeit:} \quad T(n) = \pause \begin{cases}
	1, & n = 1\\
	2 \cdot T(\fract n/2 ) + 1 \cdot n, & n > 1
	\end{cases}\]
	
	\pause
	Nach MT (Fall 2) also: $T(n) \in \Th{n \log n}$.
\end{frame}

\begin{frame}[t]{Master-Theorem: Beispiele}
	Wir betrachten verschiedene Sortierverfahren:\\
	\bigskip
	
	\begin{exampleblock}{DoubleMergesort}
		\begin{algorithm}[H]
			\KwMethod DoubleMergesort$(L: \|List| \: \KwSty{with} \size{L} = n)$\KwEmptyBlock{
				teile $L$ in der Mitte auf in $L_1$ und $L_2$ \;
				sortiere $L_1$ und $L_2$ \textbf{jeweils zwei Mal} rekursiv mit DoubleMergesort \;
				\RComment{Ja, das ist natürlich konstruierter Blödsinn!} \;
				füge $L_1$ und $L_2$ in $\Th{n}$ zusammen
			}
		\end{algorithm}
	\end{exampleblock}	
	
	\[\text{Laufzeit:} \quad T(n) = \pause \begin{cases}
	1, & n = 1\\
	4 \cdot T(\fract n/2 ) + 1 \cdot n,  & n > 1
	\end{cases}\]
	
	\pause
	Nach MT (Fall 3) also: $T(n) \in \Th{n^{\log_2 4}} = \Th{n^2}$.
\end{frame}

\begin{frame}[t]{Master-Theorem: Beispiele}
	Wir betrachten verschiedene Sortierverfahren:\\
	\bigskip
		
	\begin{exampleblock}{Magicsort}
		\begin{algorithm}[H]
			\KwMethod Magicsort$(L: \|List| \: \KwSty{with} \size{L} = n)$\KwEmptyBlock{
				teile $L$ in der Mitte auf in $L_1$ und $L_2$ \;
				sortiere $L_1$ rekursiv mit Magicsort \;
				sortiere $L_2$ mithilfe eines Flaschengeistes (in \textbf{Nullkommanichts}!) \;
				füge $L_1$ und $L_2$ in $\Th{n}$ zusammen
			}
		\end{algorithm}
	\end{exampleblock}
	
	\[\text{Laufzeit:} \quad T(n) = \pause \begin{cases}
	1, & n = 1\\
	1 \cdot T(\fract n/2 ) + 1 \cdot n, & n > 1
	\end{cases}\]
	
	\pause
	Nach MT (Fall 1) also: $T(n) \in \Th{n}$.
\end{frame}

\newcommand{\mastertheoreminder}{
	\scalebox{.8}{
		\begin{varwidth}{\columnwidth}
			Erinnerung Master-Theorem: \\
			$
			T(n) = \casesl{
				a,  & n = 1 \\
				\textcolor{darkgreen}{d} \cdot T\large(\frac{n}{\textcolor{blue}{b}}\large) + c\·n, & n > 1
			} 
			$ \hspace{-1.2\baselineskip} \\
			\impl 	$T(n) \in 
			\begin{cases}
			\Th{n},                                                        & \textcolor{darkgreen}{d} < \textcolor{blue}{b} \\
			\Th{n \log n},                                                 & \textcolor{darkgreen}{d} = \textcolor{blue}{b} \\
			\Th{n^{\log _{\textcolor{blue}{b}} \textcolor{darkgreen}{d}}}, & \textcolor{darkgreen}{d} > \textcolor{blue}{b}
			\end{cases}$. 	
		\end{varwidth}
	}
}

\begin{frame}{Aufgaben Master-Theorem}
	\taskheading{Master-Theorem}
	
	\begin{exampleblock}{Binäre Suche}
		\begin{algorithm}[H]
			\small
			\Function{$\|BinarySearch|(A: \KwSty{sorted} \KwArray[a..b] \KwOf \|Elem|, \, e: \|Elem|): \|Elem|$}{
				\begin{wrapfigure}{r}[0pt]{.4\textwidth}
					\vspace{-\baselineskip}
					\fbox{\mastertheoreminder}
				\end{wrapfigure}
				\eIf{$a = b$}{
					\Return{$\casesl{A[a], & \text{falls } A[a] = e \\ \bot, & \text{falls } A[a] \neq e}$}	
				}{
					$m := \floor{\fract a+b/2 }$ \; \smallskip
					\eIf{$e \leq A[m]$}{
						\mbox{\Return{$\|BinarySearch|(A[a \dots m], \, e) $ \RComment{A wird \textbf{nicht} kopiert!}}}
					}{
						\mbox{\Return{$\|BinarySearch|(A[m+1 \dots b], \, e)$ \RComment{A wird \textbf{nicht} kopiert!}}}
					}
				}
			}
		\end{algorithm}
	\end{exampleblock}
	Ermittelt die Laufzeit von BinarySearch.
\end{frame}

\begin{frame}[t]{Aufgaben Master-Theorem}
	\solutionheading \smallskip
	Laufzeit von BinarySearch ist $T(n) = \casesl{1, & n = 1 \\ 1 \· T(\fract n/2 ) {\color<3->{alertcolor} \vphantom{.} + 1}, & n > 1 }.$ \\
	\pause \smallskip
	\impl Master-Theorem sagt 
		\only<.(1)|handout:0>{$T(n) \in \Th{n}$}%
		\only<.(2)->{$\xcancel{T(n) \in \Th{n}}$}. \\
	\pause
	\impl \textbf{Reingefallen}! :P Master-Theorem will noch „$\color{alertcolor} \vphantom{.} + c\·n$“. \textbf{Gibt's hier nicht}! \\ 
	\pause \medskip
	Hirn einschalten: BinarySearch \textbf{halbiert das Array} in jedem Durchlauf. \\
	Wie oft kann man $n := \size{A}$ halbieren? \\
	\pause \smallskip
	\impl $(\log_2 n)$-mal. \\
	\impl $T(n) \in \Th{\log n}$.
\end{frame}

\begin{frame}{Binäre Suche: Exkurs}
\textbf{Binäre Suche: Generelles Prinzip}
\begin{itemize}
	\item Grundmenge muss \bfalert{sortiert} sein!
	\pause
	\item Generelles Suchprinzip: \\ Findet nicht nur Elemente in Arrays, sondern auch
	\implitem Nullstellen/Inverse monotoner Funktionen (falls vorhanden)
	\implitem Größte Arbeitslast eines Mehrkernsystems, die noch sinnvoll tragbar ist
	\implitem \dots
\end{itemize}
\end{frame}

\begin{frame}{Aufgaben Master-Theorem}
	\taskheading{Master-Sandwich}
	\begin{wrapfigure}{r}[-.2\baselineskip]{.38\textwidth}
		\vspace{-2.5\baselineskip}
		\fbox{\mastertheoreminder}
	\end{wrapfigure}
	Die Laufzeit eines Algorithmus~A \\
	wird beschrieben durch \\ \smallskip
	\begin{math}
	T(n) = 
	\begin{cases}
	17,                           			   &n = 1 \\
	3 \cdot T(\ceil{\frac{n}{5}}) + 2n + 1,  &  n > 1
	\end{cases}.
	\end{math} \\ \bigskip
	
	\mbox{Berechnet die Laufzeit von A mit dem Master-Theorem.}
\end{frame}

\begin{frame}{Master-Sandwich}
	\solutionheading 
	 Definiere 
	 \begin{align*}
		T_-(n) &:= 
		\begin{cases}
		17,                           			   &n = 1 \\
		3 \cdot T_-(\ceil{\frac{n}{5}}) + \alert{2n},  &  n > 1
		\end{cases}, \\
		T_+(n) &:= 
		\begin{cases}
		17,                           			   &n = 1 \\
		3 \cdot T_+(\ceil{\frac{n}{5}}) + \alert{3n} ,  &  n > 1
		\end{cases}.
	\end{align*}
		
	\medskip
	Dann gilt $\forall n \geq 1: \quad T_-(n) \leq T(n) \leq T_+(n)$.\\
	Für $T_-$ und $T_+$ gilt jeweils nach MT (Fall 1): \quad $ T_+(n), T_-(n) \in \Th{n}$.\\
	Damit liegt auch $T(n) \in \Th{n}. \qed$
		
\end{frame}

\begin{frame}{Aufgaben Master-Theorem}
	\taskheading{Master-Theorem}
	\begin{wrapfigure}{r}[-.2\baselineskip]{.38\textwidth}
		\fbox{\mastertheoreminder}
	\end{wrapfigure}
	Die Laufzeit eines Algorithmus~A \\
	wird beschrieben durch \\ \smallskip
	\begin{math}
	U(n) = 
	\begin{cases}
	1,                           			   &n = 1 \\
	7 \cdot U(\ceil{\frac{n}{2}}) + n,  &  n > 1
	\end{cases}.
	\end{math} \\ \bigskip
	Ein weiterer Algorithmus~B hat die Laufzeit \\ \smallskip
	\begin{math}
	V(n) = 
	\begin{cases}
	1,                            				& n = 1 \\
	a \cdot V(\ceil{\frac{n}{4}}) + 5n,  & n > 1
	\end{cases}.
	\end{math} \\ \bigskip
	Was ist der größte Wert $a \in \N$, so dass B asymptotisch schneller als A ist?
\end{frame}

\begin{frame}{Aufgaben Master-Theorem}
	\solutionheading 
	\begin{itemize}
		\item Master-Theorem: Algorithmus A hat Laufzeit $\Theta(n^{\log _{2}7})$, wächst also stärker als $n^2$
		\pause
		\item Fall $a \leq 4$ also uninteressant $\impl a > 4$, d.~h. Algorithmus B läuft in $\Theta(n^{\log _{4}a})$ \\
		\pause 
		\item Also: 
		\begin{align*}
			\log_{4}a &< \log_{2}7 \gdw \underbrace{4^{\log_{4}a}}_{= a} < 4^{\log_{2}7} = 7^{\log_{2} 4} = 7^2 = 49 \\ \pause  %[3] for no pause Pause is NEEDED for rendering!
			\Impl a &= 48.
		\end{align*}
		%(wobei \ $\log_x y = \frac{\log y}{\log x}$ \ und \ $\log x = \log_2 x$)
	\end{itemize}
\end{frame}


\begin{frame}{Rekurrenzen lösen}
	\taskheading{Rekurrenzen lösen}
	Gegeben sei folgende Rekurrenz für $n = 4^k, k \in \N_0$ \\[0,5cm]
	\begin{math}
	T(n) = 
	\begin{cases}
	2,                       & \text{für } n = 1 \\
	2 \cdot T(\frac{n}{4}),  & \text{für } n > 1
	\end{cases}
	\end{math} \\[0,5cm]
	Findet eine Funktion $f : \N \functionto \R^+$ und Konstanten $c_1, c_2$, so dass $c_1 \cdot f(n) \leq T(n) \leq c_2 \cdot f(n)$ und beweist euren Fund.
	
	\pause
	\bigskip
	\textbf{Tipp}: Vorstellung eines \enquote{Berechnungsbaums}: Auf jeder Ebene doppelte Anzahl der Probleme mit geviertelter Problemgröße.\\ \pause
	\impl Anzahl Blätter: \quad $2^{\log_{4}n} = n^{\log_{4}2} = n^{1/2} = \sqrt{n} = f(n)$ \quad {\small (nicht $T(n)$!)}
\end{frame}

\begin{frame}{Rekurrenzen lösen}
	\solutionheading \smallskip
	\hanging{\textbf{Behauptung} (Magie! \smiley): \quad $c_1 := 1$, $c_2 := 3$\ und\ $f(n) := \sqrt{n}$ 
	\newline erfüllen die Bedingung $\ \forall n = 4^k, k \in \N_0$} \\ \pause
	\textbf{Beweis} durch vollständige Induktion über $k$: \\ 
	\hanging{\textbf{IA}. $(k = 0 \impl n = 4^0 = 1$): \newline $1\cdot \sqrt{1} = 1 \leq T(1) = 2 \leq 3\cdot \sqrt{1} = 3$} \\ \pause
	\hanging{\textbf{IV}.: Für ein beliebiges, aber festes $k \in \N_0$\; $(n = 4^k)$ gelte \newline  $1 \cdot \sqrt{4^k} \leq T(n) \leq 3 \cdot \sqrt{4^k}$  \quad $\left(\gdw 1 \cdot \sqrt{n} \leq T(n) \leq 3 \cdot \sqrt{n}\right)$} \\ \pause
	\hanging{\textbf{IS}. ($k \rightsquigarrow k+1$): Es gilt: \vspace{-.5\baselineskip}
		\begin{align*}
			T\left(4^{k+1}\right) &\stackrel{Def.}{=} 2 \cdot T\left(\frac{4^{k+1}}{4}\right) = 2 \cdot T(n) \\ \pause
			2 \cdot T(n) &\stackrel{IV}{\geq} 2 \cdot 1 \cdot \sqrt{n} = \sqrt{4} \cdot \sqrt{n} = \sqrt{4n} = \sqrt{{4^{k+1}}} \\ \pause
			2 \cdot T(n) &\stackrel{IV}{\leq} 2 \cdot 3 \cdot \sqrt{n} = 3 \cdot \sqrt{4} \cdot \sqrt{n} = 3 \cdot \sqrt{4n} = 3 \cdot \sqrt{{4^{k+1}}}.\ \qed 
		\end{align*}
	}
\end{frame}
	

\thassedaniel{
	\xkcdframe{1724}{Danke für eure Aufmerksamkeit! \smiley}{0}
}{
	\xkcdframe{297}{May the Fourth Be With You! \smiley}{0}
}

% TODO xkcd, possibly https://xkcd.com/1477/  ?
% BETTER https://www.xkcd.com/297/

\slideThanks
	
\end{document}