%beamer

%\PassOptionsToClass{handout}{beamer}

\input{../preamble/tutpreamble}

% parent[] und d[] nachrüsten! S. Hinweis algotut10

\begin{document}
	
\starttut{9}
	
\sectionheadframe{Graphen durchlaufen}{Hänsel und Gretel im Tiefensuchwald}

\begin{frame}{Graphen durchlaufen}
	\begin{itemize}
		\item \textbf{Geg}.: Startknoten $s \in V$
		\item \textbf{Ziel}: Von $s$ aus alle weiteren Knoten besuchen
		\pause
		\item \textbf{Aber}: Keine \textbf{Doppel}besuche/Endlosschleifen \impl \textbf{Merke} besuchte Knoten
	\end{itemize}
\end{frame}

\morescalingdelimiters

\begin{frame}{Graphen durchlaufen – Tiefensuche}
	\begin{exampleblock}{Intuitive Implementierung: Tiefensuche}
		\begin{algorithm}[H]
			\small
			\Function{DFS-Forest$(G = (V, E)): (\KwArrayOf V, \KwArrayOf \N_0)$} {
				$visited = (\KwFalse, ... , \KwFalse): \KwArrayOf \|Boolean|$ \;
				$parent = (\bot, ... , \bot): \KwArrayOf V$, \qquad $d = (0, ..., 0): \KwArrayOf \N_0$  \;
				\smallskip
				\Procedure{DFS$(u,\, prev: V)$} {
					\If{$\neg visited[u]$} {
						visit$(u)$  \RComment{Do something with u} \;
						$visited[u] := \KwTrue, \quad parent[u] := prev, \quad  d[u] := d[prev] + 1$\;
						\ForEach{$(u, v) \in E$} {
							DFS$(v,\, prev = u)$
						}
					}
				}
				\smallskip
				\For{$v \in V$}{
					\If{$\neg visited[v]$}{
						DFS$(v,\, prev = v)$	
					}	
				}
				\Return{$(parent, d)$}
			}
		\end{algorithm}
		\mycomment{
			\Procedure{DFS$(G = (V, E),\ s \in V)$} {
				DFSrec$\left(G, s,\ (\KwFalse, ... , \KwFalse)\right)$\;
			}
			\;
			\Procedure{DFSrec$(G = (V, E),\ u \in V, visited : \KwArrayOf Boolean)$} {
				\If{$\neg visited[u]$} {
					visit$(u)$  \RComment{Do something with u} \;
					$visited[u] := \KwTrue$\;
					\;
					\ForEach{$(u, v) \in E$} {
						DFSrec$(G, v, visited)$\;
					}
				}
			}
		}
	\end{exampleblock}
\end{frame}

\begin{frame}{Graphen durchlaufen – Tiefensuche}
	\taskheading{Tiefe in freier Wildbahn} 
	Führt auf diesem Graphen Tiefensuche von $s$ ausgehend aus und malt den Tiefensuchwald. Nachbarn werden in alphabetischer Reihenfolge besucht.
	\vspace{-\baselineskip}
	\begin{figure}[htp]
		\centering
		\includegraphics[height=6cm]{beispielgraph-edited}
	\end{figure}
\end{frame}

\begin{frame}{Graphen durchlaufen – Tiefensuche}
	\solutionheading
	Besuchsreihenfolge: \\ s, a, b, c, e, h, g, f, d, i, j, k
	\begin{figure}[htp]
		\centering
		\includegraphics[height=6cm]{beispielDFS-edited}
	\end{figure}
\end{frame}

\begin{frame}{Graphen durchlaufen – Tiefensuche}
	\begin{itemize}
		\item<+-> \textbf{Beobachtung}: Dringt schnell \textbf{tief} in den Graphen ein, anstatt sich „auszubreiten“ (daher der Name)
		\item<+-> \textbf{Laufzeit}? \visible<+->{$\Theta(n+m)$} \\ 
		\NoQuestionE{In-place?}{(wegen $visited$, $parent$ und Rekursion)}
		\item<+-> Etwas chaotische Laufwege -- geht's auch organisierter?
	\end{itemize}
\end{frame}

\begin{frame}{Graphen durchlaufen – Breitensuche}
	\begin{exampleblock}{Organisierte Reihenfolge: Breitensuche}
		\begin{algorithm}[H]
			\Procedure{BFS$(G = (V, E),\ s \in V)$} {
				$visited := (\KwFalse, ... , \KwFalse)$\;
				$Q := \{s\}$ \;
				\While{$Q \neq \emptyset$} {
					$u := Q.\text{popFront}()$\;
					\If{$\neg visited[u]$} {
						visit$(u)$ \RComment{Do something with u} \;
						$visited[u] := \KwTrue$\;
						\ForEach{$(u, v) \in E$} {
							$Q.\text{pushBack}(v)$\;
						}
					}
				}
			}
		\end{algorithm}
	\end{exampleblock}
\end{frame}

\begin{frame}{Graphen durchlaufen – Breitensuche}
	\vspace{-.2\baselineskip}
	\begin{exampleblock}{Organisierte Reihenfolge: Breitensuche \textbf{mit Layer-Counter}}
		\begin{algorithm}[H]
			\small
			\Procedure{BFS-with-LayerCounter$(G = (V, E),\ s \in V)$} {
				$visited := (\KwFalse, ... , \KwFalse)$\;
				$Q := \{s\},$ \quad \alert{$Q' := \emptyset$}  \RComment{Extra queue Q'} \;
				\alert{$layer := 0$} \RComment{For counting the layers of traversal} \;
				\While{$Q \neq \emptyset$} {
					$u := Q.\text{popFront}()$\;
					\If{$\neg visited[u]$} {
						visit$(u, \alert{layer})$  \RComment{Do something with u and layer} \;
						$visited[u] := \KwTrue$ \;
						\ForEach{$(u, v) \in E$} {
							$Q'.\text{pushBack}(v)$  \RComment{Append to next-queue Q'} \;
						}
					}
					\alert{
						\If{$Q = \emptyset$}{ 
							$(Q, Q') := (Q', Q)$ \RComment{New layer, so swap queues} \;
							$layer\pp$ \;
						}
					}
				}
			}
		\end{algorithm} \vspace{-.4\baselineskip}
	\end{exampleblock}
\end{frame}

\begin{frame}{Graphen durchlaufen – Breitensuche}
	\taskheading{Volle Breitseite}
	Führt auf diesem Graphen Breitensuche von $s$ ausgehend aus. Nachbarn werden in alphabetischer Reihenfolge besucht.
	\begin{figure}[htp]
		\centering
		\includegraphics[height=6cm]{beispielgraph-edited}
	\end{figure}
\end{frame}

\begin{frame}{Graphen durchlaufen – Breitensuche}
	\solutionheading
	Besuchsreihenfolge: \\ s,\quad a, c, d, \quad b, e, f, g, i, j, \quad h, k
	\begin{figure}[htp]
		\centering
		\includegraphics[height=6cm]{beispielBFSwithLayers}
	\end{figure}
\end{frame}

\begin{frame}{Graphen durchlaufen – Breitensuche}
	\begin{itemize}
		\item<+-> \textbf{Beobachtung}: \textbf{Breitet} sich schnell stark \textbf{aus} (daher der Name)
		\item<+-> Offensichtlich: Findet \textbf{kürzeste Pfade} (bei \textbf{ungewichteten} Kanten)
		\item<+-> \textbf{Laufzeit}? \visible<+->{$\Theta(n+m)$} \\ 
		\NoQuestionE{In-place}{(wegen $visited$, $Q$ und $Q'$)}
	\end{itemize}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\begin{itemize}
		\item Bei BFS/DFS „entlanggelaufene“ Kanten \textbf{bilden Baum} {\small (da kein Knoten zweimal besucht!)}
		\pause
		\implitem Teile Kanten ein:
	\end{itemize}
	\vspace{-\baselineskip}
	{\small \begin{description} 
			\setlength\itemsep{0pt} % Fuck U, LATEX!
			\setlength\topsep{0pt} 
			\setlength\parskip{0pt}
		\item[\textbf{tree}-:] „Entlanggelaufene“ Kanten des Baumes
		\pause
		\item[\textbf{cross}-:] Kanten \textbf{zwischen} versch. \textbf{„Ästen“} im Baum
		\pause
		\item[\textbf{backward}-:] Kanten, die \textbf{rückwärts} zu (einer/mehreren) \emph{tree}-Kanten laufen
		\pause
		\item[\textbf{forward}-:] Kanten, die \textbf{mehrere} \emph{tree}-Kanten „\textbf{überholen}“
	\end{description}}
	\vspace{-.5\baselineskip}
	\centering
	\visible<2->{\includegraphics[width=.6\textwidth]{edgetypes}}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\taskheading{Die Graphschaft besichtigen} 
	Betrachtet die vorhin durchgespielte Tiefen- und Breitensuche und klassifiziert jeweils alle Kanten entsprechend. \vspace{-.2\baselineskip}
	\begin{figure}[htp]
		\centering
		\includegraphics[height=6cm]{beispielgraph-edited}
	\end{figure}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\solutionheading
	Für Tiefensuche: \\
	\vspace{-.3\baselineskip}
	\begin{figure}[htp]
		\centering
		\includegraphics[height=6.5cm]{beispielDFStree-edited}
	\end{figure}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\solutionheading
	Für Breitensuche:
	\vspace{-.3\baselineskip}
	\begin{figure}[htp]
		\centering
		\includegraphics[height=6.5cm]{beispielBFStree-edited}
	\end{figure}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\begin{itemize}
		\item Gibt es eine Art von Kante, die bei Breitensuche nicht auftreten kann? Falls ja, warum?
		\pause
		\implitem \textit{forward}-Kanten können \textbf{nicht} auftreten \\
		(BFS bestimmt schon den Pfad mit kleinster Kantenanzahl)
	\end{itemize}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\begin{itemize}
		\item Gibt es eine Art von Kante, die bei Tiefensuche nicht auftreten kann? Falls ja, warum?
		\pause
		\item Bei Tiefensuche können \textbf{alle} Arten von Kanten auftreten.
	\end{itemize}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\begin{itemize}
		\item Gibt es eine Art von Kante, die bei Tiefensuche \textbf{auf ungerichteten Graphen} nicht auftreten kann? Falls ja, warum?
		\pause
		\item \emph{cross}-Kanten können nicht auftreten: \\
		Wäre nämlich schon \textbf{vorher} entlanggelaufen worden (da ungerichtet!). Die einzigen Kanten, die hier das Ende eines Tiefensuch-Astes markieren können, sind \emph{backward}-/\emph{forward}-Kanten. \\
		(Ob man die jetzt \emph{backward}- oder \emph{forward}- nennt, ist wurscht, sind ja faktisch \textbf{beides}.) Bsp. dazu:
	\end{itemize}
	\centering
	\visible<2->{\includegraphics[width=.35\textwidth]{backward-dfs-undirected}}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\begin{itemize}
		\item Sind \emph{cross}-Kanten eindeutig? Falls ja, warum?
		\pause
		\item \emph{cross}-Kanten sind genau dann eindeutig, wenn der zugehörige Baum eindeutig ist. \impl I.~A. \textbf{nicht} der Fall (da Nachbarn i.~A. nicht in bestimmter Reihenfolge gewählt).
	\end{itemize}
\end{frame}

\begin{frame}{Graphen durchlaufen – Kantentypen}
	\begin{itemize}
		\item Nach welcher Strategie muss bei Tiefensuche die Reihenfolge der rekursiven Abstiege (also die Reihenfolge der Nachbarn) gewählt werden, damit keine \textit{forward}-Kanten auftreten?
		\pause
		\item \textbf{Fangfrage}! :P \\
		Es gibt \textbf{keine} solche Strategie; \emph{forward}-Kanten bei DFS in manchen Fällen unvermeidbar
	\end{itemize}
\end{frame}	

\xkcdframevert{761}{}{1.5}

\only<beamer:0>{\slideThanks}

\end{document}